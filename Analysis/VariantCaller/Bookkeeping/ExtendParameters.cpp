/* Copyright (C) 2012 Ion Torrent Systems, Inc. All Rights Reserved */

#include "ExtendParameters.h"
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include <iostream>
#include <string>
#include <sys/stat.h>
#include <errno.h>
#include "MiscUtil.h"

using namespace std;


void VariantCallerHelp() {
  printf("Usage: tvc [options]\n");
  printf("\n");

  printf("Flow space consensus:\n");
  printf("  consensus                                         generate flow space consensus reads by re-basecalling reads that are flow-synchronized\n");
  printf("\n");

  printf("General options:\n");
  printf("  -h,--help                                         print this help message and exit\n");
  printf("  -v,--version                                      print version and exit\n");
  printf("  -n,--num-threads                      INT         number of worker threads [2]\n");
  printf("  -N,--num-variants-per-thread          INT         worker thread batch size [500]\n");
  printf("     --parameters-file                  FILE        json file with algorithm control parameters [optional]\n");
  printf("     --do-indel-assembly                on/off      use indel assembler to call long indel variants [on]\n");
  printf("\n");

  printf("Inputs:\n");
  printf("  -r,--reference                        FILE        reference fasta file [required]\n");
  printf("  -b,--input-bam                        FILE        bam file with mapped reads [required]\n");
  printf("  -g,--sample-name                      STRING      sample for which variants are called (In case of input BAM files with multiple samples) [optional if there is only one sample]\n");
  printf("     --force-sample-name                STRING      force all read groups to have this sample name [off]\n");
  printf("  -t,--target-file                      FILE        only process targets in this bed file [optional]\n");
  printf("     --trim-ampliseq-primers            on/off      match reads to targets and trim the ends that reach outside them [off]\n");
  printf("  -D,--downsample-to-coverage           INT         downsample reads to this value for flow-space evaluation [2000]\n");
  printf("     --model-file                       FILE        HP recalibration model input file.\n");
  printf("     --recal-model-hp-thres             INT         Lower threshold for HP recalibration.\n");
  printf("\n");

  printf("Outputs:\n");
  printf("  -O,--output-dir                       DIRECTORY   base directory for all output files [current dir]\n");
  printf("  -o,--output-vcf                       FILE        vcf file with small variant calling results [small_variants.vcf]\n");
  printf("     --assembly-vcf                     FILE        vcf file with indel assembly results [indel_assembly.vcf]\n");
  //printf("     --merged-vcf                       FILE        merged and post processed vcf file [TSVC_variants.vcf]\n");
  printf("     --suppress-reference-genotypes     on/off      write reference calls into the filtered variants vcf [on]\n");
  printf("     --suppress-no-calls                on/off      write filtered variants into the filtered variants vcf [on]\n");
  printf("     --suppress-nocall-genotypes        on/off      do not report a genotype for filtered variants [on]\n");
  printf("     --report-ppa                       on/off      report Possible Polyploidy Alleles (PPA) [off]\n");
  printf("     --candidate-list-file              FILE        list all the novel candidates generated by freebayes [optional]\n");
  printf("\n");

  printf("Variant candidate generation (FreeBayes):\n");
  printf("     --allow-snps                       on/off      allow generation of snp candidates [on]\n");
  printf("     --allow-indels                     on/off      allow generation of indel candidates [on]\n");
  printf("     --allow-mnps                       on/off      allow generation of mnp candidates [on]\n");
  printf("     --allow-complex                    on/off      allow generation of block substitution candidates [off]\n");
  printf("     --max-complex-gap                  INT         maximum number of reference alleles between two alternate alleles to allow merging of the alternate alleles [1]\n");
  printf("  -m,--use-best-n-alleles               INT         maximum number of snp alleles [2]\n");
  printf("     --use-best-n-nonsnp-alleles        INT         maximum number of non-snp alleles [0, no limit]\n");
  printf("  -M,--min-mapping-qv                   INT         do not use reads with mapping quality below this [4]\n");
  printf("  -U,--read-snp-limit                   INT         do not use reads with number of snps above this [10]\n");
  printf("     --read-mismatch-limit              INT         do not use reads with number of mismatches (where 1 gap open counts 1) above this value (0 to disable this option) [0]\n");
  printf("     --min-cov-fraction                 FLOAT       do not use reads with fraction of covering the best assigned (unmerged) target region below this [0.0]\n");
  printf("  -z,--read-max-mismatch-fraction       FLOAT       do not use reads with fraction of mismatches above this [1.0]\n");
  printf("     --gen-min-alt-allele-freq          FLOAT       minimum required alt allele frequency to generate a candidate [0.2]\n");
  printf("     --gen-min-indel-alt-allele-freq    FLOAT       minimum required alt allele frequency to generate an indel candidate [0.2]\n");
  printf("     --gen-min-coverage                 INT         minimum required coverage to generate a candidate [6]\n");
  printf("     --max-alt-num                      INT         try to break the variant if the number of alt alleles is greater than this value. [20]\n");
  printf("     --merge-variant-lookahead          INT         how many bases ahead to merge nearby variant to form correct haplotype [-1 use auto-adapt, 0 if not allow complex]\n");
  printf("     --allele-cigar-output              on/off      output cigar for alt alleles [off]\n");
  printf("\n");

  printf("External variant candidates:\n");
  printf("  -l,--sse-vcf                          FILE        vcf.gz file (+.tbi) with sse candidate variant locations and alleles [optional]\n");
  printf("  -c,--input-vcf                        FILE        vcf.gz file (+.tbi) with additional candidate variant locations and alleles [optional]\n");
  printf("     --process-input-positions-only     on/off      only generate candidates at locations from input-vcf [off]\n");
  printf("     --use-input-allele-only            on/off      only consider provided alleles for locations in input-vcf [off]\n");
  printf("\n");

  printf("Variant candidate scoring options:\n");
  printf("     --min-delta-for-flow               FLOAT       minimum prediction delta for scoring flows [0.1]\n");
  printf("     --max-flows-to-test                INT         maximum number of scoring flows [10]\n");
  printf("     --outlier-probability              FLOAT       probability for outlier reads [0.01]\n");
  printf("     --heavy-tailed                     INT         (2*this value-1) is the Degrees of Freedom (DoF) in t-dist modeling signal residual heavy tail [3]\n");
  printf("     --adjust-sigma                     on/off      It true, use sigma^2=(DoF-2)/Dof*VAR(residual) for calculating the t-dist log-likelihood, else use sigma^2=VAR(residual) [off]\n");
  printf("     --suppress-recalibration           on/off      Suppress homopolymer recalibration [on].\n");
  printf("     --do-snp-realignment               on/off      Realign reads in the vicinity of candidate snp variants [on].\n");
  printf("     --do-mnp-realignment               on/off      Realign reads in the vicinity of candidate mnp variants [do-snp-realignment].\n");
  printf("     --realignment-threshold            FLOAT       Max. allowed fraction of reads where realignment causes an alignment change [1.0].\n");
  printf("\n");

  printf("Advanced variant candidate scoring options:\n");
  printf("     --use-sse-basecaller               on/off      Switch to use the vectorized version of the basecaller [on].\n");
  printf("     --resolve-clipped-bases            on/off      If 'true', the basecaller is used to solve soft clipped bases [off].\n");
  printf("     --prediction-precision             FLOAT       prior weight in bias estimator [30.0]\n");
  printf("     --shift-likelihood-penalty         FLOAT       penalize log-likelihood for solutions involving large systematic bias [0.3]\n");
  printf("     --minimum-sigma-prior              FLOAT       prior variance per data point, constant [0.085]\n");
  printf("     --slope-sigma-prior                FLOAT       prior rate of increase of variance over minimum by signal [0.0084]\n");
  printf("     --sigma-prior-weight               FLOAT       weight of prior estimate of variance compared to observations [1.0]\n");
  printf("     --k-zero                           FLOAT       variance increase for adding systematic bias [3.0]\n");
  printf("     --sse-relative-safety-level        FLOAT       dampen strand bias detection for SSE events for low coverage [0.025]\n");
  printf("     --tune-sbias                       FLOAT       dampen strand bias detection for low coverage [0.01]\n");
  printf("     --max-detail-level                 INT         number of evaluated frequencies for a given hypothesis, reduce for very high coverage, set to zero to disable this option [0]\n");
  printf("     --min-detail-level-for-fast-scan   INT         minimum detail level to trigger the fast scan for log-posterior of frequencies [0]\n");
  printf("     --try-few-restart-freq             on/off      speed up the evaluator by trying fewer initial guesses of allele frequency [off].\n");

  printf("\n");

  printf("Variant filtering:\n");
  // Filters depending on the variant type
  printf("     --use-fd-param                     on/off      use flow-disruptiveness to choose parameter set. If on, map inputed (INDEL,SNP,MNP) to (fd-0,fd-5,fd-10) if fd parameters not specified [off]\n");
  printf("     --min-ratio-for-fd                 FLOAT       claim flow-disruption if the portion of reads that are flow-disrupted >= this value [0.1]\n");
  printf("     --fd-nonsnp-min-var-cov            INT         override min-var-coverage of the flow-disrupted variants that are not snp (0 to disable the override) [0]\n");
  printf("     --hotspots-as-de-novo              on/off      treat hotspots as de novo during filtering [off]\n");
  // Filters not depending on the variant score
  printf("  -L,--hp-max-length                    INT         filter out indels in homopolymers above this [8]\n");
  printf("     --hp-indel-hrun                    INT VECTOR  define the HRUN for filtering HP-INDEL variants [7,8]\n");
  printf("     --hp-ins-len                       INT VECTOR  filter out HP-INS variants whose INS length <= the corresponding entry of this vector if the HRUN is defined in hp-indel-hrun [0,0]\n");
  printf("     --hp-del-len                       INT VECTOR  filter out HP-DEL variants whose DEL length <= the corresponding entry of this vector if the HRUN is defined in hp-indel-hrun [0,0]\n");
  printf("     --error-motifs-dir                 FILE        directory where the error-motifs files can be found [optional]\n");
  printf("  -e,--error-motifs                     FILE        table of systematic error motifs and their error rates [optional]\n");
  printf("     --sse-prob-threshold               FLOAT       filter out variants in motifs with error rates above this [0.2]\n");
  printf("     --min-ratio-reads-non-sse-strand   FLOAT       minimum required alt allele frequency for variants with error motifs on opposite strand [0.2]\n");
  printf("     --use-lod-filter                   on/off      enable the Limit Of Detection (LOD) filter [off]\n");
  printf("     --lod-multiplier                   FLOAT       multiplier of LOD for filtering out variants with low alt allele frequency [0.6]\n");
  printf("     --tag-sim-max-cov                  INT         check the similarity of variant molecular tags if the variant molecular coverage <= this value [20]\n");
  printf("     --cleanup-unlikely-candidates      on/off      remove unlikely variant candidates from the vcf records if there is a highly likely variant presented (similar to heal-snps) [on].\n");

  printf("\nVariant filtering for hotspot alleles (default X = fd-10 if use-fd-param else X = snp):\n");
  printf("     --hotspot-min-allele-freq          FLOAT       minimum required alt allele frequency for hotspot variant call [X-min-allele-freq]\n");
  printf("     --hotspot-min-coverage             INT         filter out hotspot variants with total coverage below this [X-min-coverage]\n");
  printf("     --hotspot-min-cov-each-strand      INT         filter out hotspot variants with coverage on either strand below this [X-min-cov-each-strand]\n");
  printf("     --hotspot-min-var-coverage         INT         filter out hotspot variants with hard-classified variant allele coverage below this [X-min-cov-each-strand]\n");
  printf("     --hotspot-min-variant-score        FLOAT       filter out hotspot variants with QUAL score below this [X-min-variant-score]\n");
  printf("     --hotspot-strand-bias              FLOAT       filter out hotspot variants with strand bias above this [X-strand-bias] given strand bias > hotspot-strand-bias\n");
  printf("     --hotspot-strand-bias-pval         FLOAT       filter out hotspot variants with pval below this [X-strand-bias-pval] given pval < hotspot-strand-bias-pval\n");

  printf("\nVariant filtering for fd-0 (non-flow-disrupted, i.e., HP-INDEL) alleles:\n");
  printf("     --fd-0-min-allele-freq             FLOAT       minimum required alt allele frequency for fd-0 variant call [0.2]\n");
  printf("     --fd-0-min-coverage                INT         filter out fd-0 variants with total coverage below this [30]\n");
  printf("     --fd-0-min-cov-each-strand         INT         filter out fd-0 variants with coverage on either strand below this [1]\n");
  printf("     --fd-0-min-var-coverage            INT         filter out fd-0 variants with hard-classified variant allele coverage below this [0]\n");
  printf("     --fd-0-min-variant-score           FLOAT       filter out fd-0 variants with QUAL score below this [10.0]\n");
  printf("     --fd-0-strand-bias                 FLOAT       filter out fd-0 variants with strand bias above this [0.95] given strand bias > fd-0-strand-bias\n");
  printf("     --fd-0-strand-bias-pval            FLOAT       filter out fd-0 variants with pval below this [1.0] given pval < fd-0-strand-bias-pval\n");

  printf("\nVariant filtering for fd-5 (moderate flow-disrupted) alleles:\n");
  printf("     --fd-5-min-allele-freq             FLOAT       minimum required alt allele frequency for fd-5 variant call [fd-0-min-allele-freq]\n");
  printf("     --fd-5-min-coverage                INT         filter out fd-5 variants with total coverage below this [fd-0-min-coverage]\n");
  printf("     --fd-5-min-cov-each-strand         INT         filter out fd-5 variants with coverage on either strand below this [fd-0-min-cov-each-strand]\n");
  printf("     --fd-5-min-var-coverage            INT         filter out fd-5 variants with hard-classified variant allele coverage below this [fd-0-min-var-coverage]\n");
  printf("     --fd-5-min-variant-score           FLOAT       filter out fd-5 variants with QUAL score below this [fd-0-min-variant-score]\n");
  printf("     --fd-5-strand-bias                 FLOAT       filter out fd-5 variants with strand bias above this [fd-0-strand-bias] given strand bias > fd-5-strand-bias\n");
  printf("     --fd-5-strand-bias-pval            FLOAT       filter out fd-5 variants with pval below this [fd-0-strand-bias-pval] given pval < fd-5-strand-bias-pval\n");

  printf("\nVariant filtering for fd-10 (most flow-disrupted) alleles:\n");
  printf("     --fd-10-min-allele-freq             FLOAT       minimum required alt allele frequency for fd-10 variant call [0.2]\n");
  printf("     --fd-10-min-coverage                INT         filter out fd-10 variants with total coverage below this [6]\n");
  printf("     --fd-10-min-cov-each-strand         INT         filter out fd-10 variants with coverage on either strand below this [0]\n");
  printf("     --fd-10-min-var-coverage            INT         filter out fd-10 variants with hard-classified variant allele coverage below this [0]\n");
  printf("     --fd-10-min-variant-score           FLOAT       filter out fd-10 variants with QUAL score below this [10.0]\n");
  printf("     --fd-10-strand-bias                 FLOAT       filter out fd-10 variants with strand bias above this [0.95] given strand bias > fd-10-strand-bias\n");
  printf("     --fd-10-strand-bias-pval            FLOAT       filter out fd-10 variants with pval below this [1.0] given pval < fd-10-strand-bias-pval\n");

  printf("\nParameters that will be deprecated in the future:\n");
  printf("     --snp-min-coverage                 INT         filter out snps with total coverage below this [6]\n");
  printf("     --snp-min-cov-each-strand          INT         filter out snps with coverage on either strand below this [0]\n");
  printf("     --snp-min-variant-score            FLOAT       filter out snps with QUAL score below this [10.0]\n");
  printf("     --snp-strand-bias                  FLOAT       filter out snps with strand bias above this [0.95] given strand bias > snp-strand-bias\n");
  printf("     --snp-strand-bias-pval             FLOAT       filter out snps with pval below this [1.0] given pval < snp-strand-bias-pval\n");
  printf("     --snp-min-allele-freq              FLOAT       minimum required alt allele frequency for non-reference snp calls [0.2]\n");
  printf("     --snp-min-var-coverage             INT         filter out snps with variant allele coverage below this [0]\n");
  printf("     --mnp-min-coverage                 INT         filter out mnps with total coverage below this [snp-min-coverage]\n");
  printf("     --mnp-min-cov-each-strand          INT         filter out mnps with coverage on either strand below this, [snp-min-cov-each-strand]\n");
  printf("     --mnp-min-variant-score            FLOAT       filter out mnps with QUAL score below this [snp-min-variant-score]\n");
  printf("     --mnp-strand-bias                  FLOAT       filter out mnps with strand bias above this [snp-strand-bias] given strand bias > mnp-strand-bias\n");
  printf("     --mnp-strand-bias-pval             FLOAT       filter out mnps with pval below this [snp-strand-bias-pval] given pval < mnp-strand-bias-pval\n");
  printf("     --mnp-min-allele-freq              FLOAT       minimum required alt allele frequency for non-reference mnp calls [snp-min-allele-freq]\n");
  printf("     --mnp-min-var-coverage             INT         filter out mnps with variant allele coverage below this [snp-min-var-coverage]\n");
  printf("     --indel-min-coverage               INT         filter out indels with total coverage below this [30]\n");
  printf("     --indel-min-cov-each-strand        INT         filter out indels with coverage on either strand below this [1]\n");
  printf("     --indel-min-variant-score          FLOAT       filter out indels with QUAL score below this [10.0]\n");
  printf("     --indel-strand-bias                FLOAT       filter out indels with strand bias above this [0.95] given strand bias > indel-strand-bias\n");
  printf("     --indel-strand-bias-pval           FLOAT       filter out indels with pval below this [1.0] given pval < indel-strand-bias-pval\n");
  printf("     --indel-min-allele-freq            FLOAT       minimum required alt allele frequency for non-reference indel call [0.2]\n");
  printf("     --indel-min-var-coverage           INT         filter out indels with variant allele coverage below this [snp-min-var-coverage]\n");
  printf("     --indel-as-hpindel                 on/off      apply indel filters to non HP indels [off]\n");
  printf("     --heal-snps                        on/off      suppress in/dels not participating in diploid variant genotypes if the genotype contains a SNP or MNP [on].\n");

  // position-bias filter
  printf("\nPosition bias variant filtering:\n");
  printf("     --use-position-bias                on/off      enable the position bias filter [off]\n");
  printf("     --position-bias                    FLOAT       filter out variants with position bias relative to soft clip ends in reads > position-bias [0.75]\n");
  printf("     --position-bias-pval               FLOAT       filter out if position bias above position-bias given pval < position-bias-pval [0.05]\n");
  printf("     --position-bias-ref-fraction       FLOAT       skip position bias filter if (reference read count)/(reference + alt allele read count) <= to this [0.05]\n");
  // These filters depend on scoring
  printf("\nFilters that depend on scoring across alleles:\n");
  printf("     --data-quality-stringency          FLOAT       minimum mean log-likelihood delta per read [4.0]\n");
  printf("     --read-rejection-threshold         FLOAT       filter variants where large numbers of reads are rejected as outliers [0.5]\n");
  printf("     --filter-unusual-predictions       FLOAT       posterior log likelihood threshold for accepting bias estimate [0.3]\n");
  printf("     --filter-deletion-predictions      FLOAT       check post-evaluation systematic bias in deletions; a high value like 100 effectively turns off this filter [100.0]\n");
  printf("     --filter-insertion-predictions     FLOAT       check post-evaluation systematic bias in insertions; a high value like 100 effectively turns off this filter [100.0]\n");
  // XXX Not applicable in TS 5.4 since merging and post processing is not run in TVC
  //printf("\nVCF record filters (applied during merge):\n");
  //printf("     --filter-by-target                 on/off      Filter vcf records by meta information in the target bed file [on]\n");
  //printf("     --hotspot-positions-only           on/off      Report only hotspot vcf records in final output [off]\n");
  //printf("     --hotspot-variants-only            on/off      Suppress hotspot records that are no-calls or reference-calls  [off]\n");
  printf("\n");

  MolecularTagTrimmer::PrintHelp(true);
  printf("     --indel-func-size-offset           INT         require family of size >= (min-tag-fam-size + this value) to be functional when calling HP-INDEL [0]\n");
  printf("\n");


  printf("Debugging:\n");
  printf("  -d,--debug                            INT         (0/1/2/3) display extra debug messages [0]\n");
  printf("     --do-json-diagnostic               on/off      (devel) dump internal state to json file (uses much more time/memory/disk) [off]\n");
  printf("     --postprocessed-bam                FILE        (devel) save tvc-processed reads to an (unsorted) BAM file [optional]\n");
  printf("     --do-minimal-diagnostic            on/off      (devel) provide minimal read information for called variants [off]\n");
  printf("     --override-limits                  on/off      (devel) disable limit-check on input parameters [off].\n");
  printf("     --disable-filters                  on/off      (devel) disable most of the filtering steps for the alleles [off].\n");
  printf("     --output-multi-min-allele-freq     on/off      output the inference results for multiple min-allele-freq in vcf [off].\n");
  printf("     --multi-min-allele-freq            FLOAT VECTOR output QUAL, GT, GQ using the min-allele-freq specified in the vector [0.05,0.1,0.15,0.2].\n");
  printf("\n");
}

int mkpath(std::string s,mode_t mode)
{
    size_t pre=0,pos;
    std::string dir;
    int mdret = 0;

    if(s[s.size()-1]!='/'){
        // force trailing / so we can handle everything in loop
        s+='/';
    }

    while((pos=s.find_first_of('/',pre))!=std::string::npos){
        dir=s.substr(0,pos++);
        pre=pos;
        if(dir.size()==0) continue; // if leading / first time is 0 length
        if((mdret=mkdir(dir.c_str(),mode)) && errno!=EEXIST){
            return mdret;
        }
    }
    return mdret;
}

ControlCallAndFilters::ControlCallAndFilters() {
  // all defaults handled by sub-filters
  data_quality_stringency = 4.0f;  // phred-score for this variant per read
  read_rejection_threshold = 0.5f; // half the reads gone, filter this

  use_position_bias = false;
  position_bias_ref_fraction = 0.05;  // FRO/(FRO+FAO)
  position_bias = 0.75f;              // position bias
  position_bias_pval = 0.05f;         // pval for observed > threshold

  use_lod_filter = false;
  lod_multiplier = 0.6f;

  tag_sim_max_cov = 20;

  // VCF record filters (applied during vcf merging) XXX
  //filter_by_target       = true;  // Filter records based on mets information in target bed info field
  //hotspot_positions_only = false; // Output only vcf lines with the infoFlag 'HS'
  //hotspot_variants_only  = false; // Suppress hotspot reference calls and no-calls from the final output vcf

  //xbias_tune = 0.005f;
  sbias_tune = 0.5f;
  downSampleCoverage = 2000;
  RandSeed = 631;
  // wanted by downstream
  suppress_reference_genotypes = true;
  suppress_nocall_genotypes = true;
  suppress_no_calls = true;
  cleanup_unlikely_candidates = true;
  report_ppa = false;
  hotspots_as_de_novo = false;
  disable_filters = false;

  // Flow-disruption parameters
  fd_nonsnp_min_var_cov = 0;
  use_fd_param  = false;
  min_ratio_for_fd = 0.1f;
}

ProgramControlSettings::ProgramControlSettings() {
  nVariantsPerThread = 1000;
  nThreads = 1;
  DEBUG = 0;
  do_indel_assembly = true;
#ifdef __SSE3__
  use_SSE_basecaller = true;
#else
  use_SSE_basecaller = false;
#endif
  rich_json_diagnostic = false;
  minimal_diagnostic = false;
  inputPositionsOnly = false;
  suppress_recalibration = true;
  resolve_clipped_bases = false;

  is_multi_min_allele_freq = false;
  multi_min_allele_freq.clear();
}

// =============================================================================

void EnsembleEvalTuningParameters::SetOpts(OptArgs &opts, Json::Value& tvc_params) {

  max_flows_to_test                     = RetrieveParameterInt   (opts, tvc_params, '-', "max-flows-to-test", 10);
  min_delta_for_flow                    = RetrieveParameterDouble(opts, tvc_params, '-', "min-delta-for-flow", 0.1);

  prediction_precision                  = RetrieveParameterDouble(opts, tvc_params, '-', "prediction-precision", 30.0);
  outlier_prob                          = RetrieveParameterDouble(opts, tvc_params, '-', "outlier-probability", 0.01);
  germline_prior_strength               = RetrieveParameterDouble(opts, tvc_params, '-', "germline-prior-strength", 0.0f);
  heavy_tailed                          = RetrieveParameterInt   (opts, tvc_params, '-', "heavy-tailed", 3);
  adjust_sigma                          = RetrieveParameterBool  (opts, tvc_params, '-', "adjust-sigma", false);

  filter_unusual_predictions            = RetrieveParameterDouble(opts, tvc_params, '-', "filter-unusual-predictions", 0.3f);
  soft_clip_bias_checker                = RetrieveParameterDouble(opts, tvc_params, '-', "soft-clip-bias-checker", 0.1f);
  filter_deletion_bias                  = RetrieveParameterDouble(opts, tvc_params, '-', "filter-deletion-predictions", 100.0f);
  filter_insertion_bias                 = RetrieveParameterDouble(opts, tvc_params, '-', "filter-insertion-predictions", 100.0f);
  max_detail_level                      = RetrieveParameterInt(opts, tvc_params, '-', "max-detail-level", 0);
  min_detail_level_for_fast_scan        = RetrieveParameterInt(opts, tvc_params, '-', "min-detail-level-for-fast-scan", 0);
  try_few_restart_freq                  = RetrieveParameterBool(opts, tvc_params, '-', "try-few-restart-freq", false);

  // shouldn't majorly affect anything, but still expose parameters for completeness
  pseudo_sigma_base                     = RetrieveParameterDouble(opts, tvc_params, '-', "shift-likelihood-penalty", 0.3f);
  magic_sigma_base                      = RetrieveParameterDouble(opts, tvc_params, '-', "minimum-sigma-prior", 0.085f);
  magic_sigma_slope                     = RetrieveParameterDouble(opts, tvc_params, '-', "slope-sigma-prior", 0.0084f);
  sigma_prior_weight                    = RetrieveParameterDouble(opts, tvc_params, '-', "sigma-prior-weight", 1.0f);
  k_zero                                = RetrieveParameterDouble(opts, tvc_params, '-', "k-zero", 3.0f); // add variance from cluster shifts
}

void EnsembleEvalTuningParameters::CheckParameterLimits() {

  CheckParameterLowerUpperBound<int>  ("max-flows-to-test",       max_flows_to_test,       1,     100);
  CheckParameterLowerUpperBound<float>("min-delta-for-flow",      min_delta_for_flow,      0.01f, 0.5f);
  CheckParameterLowerBound<float>     ("prediction-precision",    prediction_precision,    0.1f);
  CheckParameterLowerUpperBound<float>("outlier-probability",     outlier_prob,            0.0000001f,  1.0f); // extremely low outlier_prob causes floating exception
  CheckParameterLowerUpperBound<float>("germline-prior-strength", germline_prior_strength, 0.0f,  1000.0f);
  CheckParameterLowerBound<int>       ("heavy-tailed",            heavy_tailed,            1);

  CheckParameterLowerBound<float>     ("filter-unusual-predictions",    filter_unusual_predictions,   0.0f);
  CheckParameterLowerUpperBound<float>("soft-clip-bias-checker",        soft_clip_bias_checker, 0.0f, 1.0f);
  CheckParameterLowerBound<float>     ("filter-deletion-predictions",   filter_deletion_bias,         0.0f);
  CheckParameterLowerBound<float>     ("filter-insertion-predictions",  filter_insertion_bias,        0.0f);
  CheckParameterLowerUpperBound<int>  ("max-detail-level",    max_detail_level,   0, 10000);
  CheckParameterLowerBound<int>       ("min-detail-level-for-fast-scan",min_detail_level_for_fast_scan,   0);


  CheckParameterLowerBound<float>     ("shift-likelihood-penalty",  pseudo_sigma_base,    0.01f);
  CheckParameterLowerBound<float>     ("minimum-sigma-prior",       magic_sigma_base,     0.01f);
  CheckParameterLowerBound<float>     ("slope-sigma-prior",         magic_sigma_slope,    0.0f);
  CheckParameterLowerBound<float>     ("sigma-prior-weight",        sigma_prior_weight,   0.01f);
  CheckParameterLowerBound<float>     ("k-zero",                    k_zero,               0.0f);
}

// ============================================================================

// I really don't want to do this.
void RetrieveParameterStringtifiedVectorIntForIR(Json::Value& json, const string& long_name_hyphens, vector<int>& ret_vector){
    string long_name_underscores = long_name_hyphens;
    for (unsigned int idx = 0; idx < long_name_underscores.size(); ++idx){
        if (long_name_underscores[idx] == '-'){
            long_name_underscores[idx] = '_';
        }
    }
    if (not json.isMember(long_name_underscores)){
        return;
    }
    if (not json[long_name_underscores].isString()){
        return;
    }
    string my_value = json[long_name_underscores].toStyledString();
    string my_vector_to_print;
    my_vector_to_print.reserve(my_value.size());
    for (string::iterator my_it = my_value.begin(); my_it != my_value.end(); ++my_it){
        // Note that the string returned from toStyledString() starts with "\"" and ends with "\"\n".
        if (*my_it != '\n' and *my_it != ' ' and *my_it != '"' and *my_it != '\t'){
            my_vector_to_print.push_back(*my_it);
        }
    }

    if (not (*(my_vector_to_print.begin()) == '[' and my_vector_to_print.back() == ']')){
        cerr << "WARNING: Skip the invalid value of the json parameter \"" << long_name_underscores << "\": \""<< my_vector_to_print << "\"" << endl;
        return;
    }

    ret_vector.resize(0);
    ret_vector.reserve(my_vector_to_print.size() / 2);
    my_value = my_vector_to_print;

    size_t comma_idx = (my_vector_to_print == "[]") ? string::npos : 0;
    while (comma_idx != string::npos and my_value.size() > 1){
        my_value.erase(0, comma_idx + 1);
        int my_entry = (int) strtol(my_value.c_str(), NULL, 0);
        if (my_entry == 0 and my_value[0] != '0'){
            cerr << "WARNING: Skip the invalid value of the json parameter \"" << long_name_underscores << "\": \""<< my_vector_to_print << "\"" << endl;
            ret_vector.clear();
            return;
        }
        ret_vector.push_back(my_entry);
        comma_idx = my_value.find(",");
    }
    cout << setw(35) << long_name_hyphens << " = " << setw(10) << my_vector_to_print << " (vector<int>, parameters json file (specified as a string))" << endl;
}

void ClassifyFilters::SetOpts(OptArgs &opts, Json::Value & tvc_params) {

  hp_max_length                         = RetrieveParameterInt   (opts, tvc_params, 'L', "hp-max-length", 8);
  sseProbThreshold                      = RetrieveParameterDouble(opts, tvc_params, '-', "sse-prob-threshold", 0.2);
  minRatioReadsOnNonErrorStrand         = RetrieveParameterDouble(opts, tvc_params, '-', "min-ratio-reads-non-sse-strand", 0.2);
  sse_relative_safety_level             = RetrieveParameterDouble(opts, tvc_params, '-', "sse-relative-safety-level", 0.025);
  // min ratio of reads supporting variant on non-sse strand for variant to be called
  do_snp_realignment                    = RetrieveParameterBool  (opts, tvc_params, '-', "do-snp-realignment", true);
  do_mnp_realignment                    = RetrieveParameterBool  (opts, tvc_params, '-', "do-mnp-realignment", do_snp_realignment);
  realignment_threshold                 = RetrieveParameterDouble(opts, tvc_params, '-', "realignment-threshold", 1.0);

  indel_as_hpindel                      = RetrieveParameterBool  (opts, tvc_params, '-', "indel-as-hpindel", false);

  RetrieveParameterVectorInt(opts, tvc_params, '-', "hp-indel-hrun", "-1,-1", filter_hp_indel_hrun);
  // Deal with the IR "stringtified" format.
  if (filter_hp_indel_hrun == vector<int>({-1, -1})){
	  RetrieveParameterStringtifiedVectorIntForIR(tvc_params, "hp-indel-hrun", filter_hp_indel_hrun);
  }
  if (filter_hp_indel_hrun == vector<int>({-1, -1})){
	  filter_hp_indel_hrun = {7, 8};
	  cout <<"                      hp-indel-hrun =        7,8 (int,  builtin default)" << endl;
  }

  RetrieveParameterVectorInt(opts, tvc_params, '-', "hp-ins-len", "-1,-1", filter_hp_ins_len);
  // Deal with the IR "stringtified" format.
  if (filter_hp_ins_len == vector<int>({-1, -1})){
	  RetrieveParameterStringtifiedVectorIntForIR(tvc_params, "hp-ins-len", filter_hp_ins_len);
  }
  if (filter_hp_ins_len == vector<int>({-1, -1})){
	  filter_hp_ins_len = {0, 0};
	  cout << "                         hp-ins-len =        0,0 (int,  builtin default)" << endl;
  }

  RetrieveParameterVectorInt(opts, tvc_params, '-', "hp-del-len", "-1,-1", filter_hp_del_len);
  // Deal with the IR "stringtified" format.
  if (filter_hp_del_len == vector<int>({-1, -1})){
	  RetrieveParameterStringtifiedVectorIntForIR(tvc_params, "hp-del-len", filter_hp_del_len);
  }
  if (filter_hp_del_len == vector<int>({-1, -1})){
	  filter_hp_del_len = {0, 0};
	  cout << "                         hp-del-len =        0,0 (int,  builtin default)" << endl;
  }
}

void ClassifyFilters::CheckParameterLimits() {

  CheckParameterLowerBound<int>       ("hp-max-length",         hp_max_length, 1);
  CheckParameterLowerUpperBound<float>("sse-prob-threshold",    sseProbThreshold, 0.0f, 1.0f);
  CheckParameterLowerUpperBound<float>("min-ratio-reads-non-sse-strand",   minRatioReadsOnNonErrorStrand, 0.0f, 1.0f);
  CheckParameterLowerUpperBound<float>("sse-relative-safety-level",   sse_relative_safety_level, 0.0f, 1.0f);
  CheckParameterLowerUpperBound<float>("realignment-threshold",   realignment_threshold, 0.0f, 1.0f);

  cout << "Size check parameters hp-indel-hrun, hp-ins-len, hp-del-len: hp_indel_hrun.size()==hp_ins_len.size()==hp_del_len.size()? ";
  if (filter_hp_indel_hrun.size() == filter_hp_ins_len.size() and filter_hp_indel_hrun.size() == filter_hp_del_len.size()){
	  cout << "OK!" << endl;
  }else{
	  cout << "Using " << "hp_indel_hrun = {7,8}, filter_hp_ins_len = {0,0}, filter_hp_del_len = {0,0} instead!" << endl;
	  filter_hp_indel_hrun = {7, 8};
	  filter_hp_ins_len = {0, 0};
	  filter_hp_del_len = {0, 0};
  }

  for (unsigned int i_hp = 0; i_hp < filter_hp_indel_hrun.size(); ++i_hp){
	  string identifier = "hp-indel-hrun[" + convertToString(i_hp) + "]";
	  CheckParameterLowerBound<int>  (identifier, filter_hp_indel_hrun[i_hp], 0);
  }
  for (unsigned int i_hp = 0; i_hp < filter_hp_ins_len.size(); ++i_hp){
	  string identifier = "hp-ins-len[" + convertToString(i_hp) + "]";
	  CheckParameterLowerBound<int>  (identifier, filter_hp_ins_len[i_hp], 0);
  }
  for (unsigned int i_hp = 0; i_hp < filter_hp_del_len.size(); ++i_hp){
	  string identifier = "hp-del-len[" + convertToString(i_hp) + "]";
	  CheckParameterLowerBound<int>  (identifier, filter_hp_del_len[i_hp], 0);
  }
}

BasicFilters::BasicFilters(const string& filter_type) {
	my_type = filter_type;
	underscored_my_type = my_type;
	for (string::iterator s_it = underscored_my_type.begin(); s_it != underscored_my_type.end(); ++s_it){
		if (*s_it == '-'){
			*s_it = '_';
		}
	}
	if (underscored_my_type == "snp" or underscored_my_type == "fd_10"){
	    min_allele_freq = 0.2f;
	    strand_bias_threshold = 0.95f;
	    strand_bias_pval_threshold = 1.0f;
	    min_quality_score = 10.0f;
	    min_cov = 6;
	    min_cov_each_strand = 0;
	    min_var_cov = 0;
	}
	else if (underscored_my_type == "indel" or underscored_my_type == "fd_0"){
	    min_allele_freq = 0.2f;
	    strand_bias_threshold = 0.95f;
	    strand_bias_pval_threshold = 1.0f;
	    min_quality_score = 10.0f;
	    min_cov = 30;
	    min_cov_each_strand = 1;
	    min_var_cov = 0;
	}
}
void BasicFilters::SetBasicFilterOpts(OptArgs &opts, Json::Value& tvc_params, BasicFilters* default_basic_filter){
	string opt_prefix;
	Json::Value tvc_params_section;
	// I will get the X parameters from the kTypeMap[X] parameters in the "torrent_variant_caller" section
    const static map<string, string> kTypeMap = {pair<string, string>("fd-10", "mnp"),
    											 pair<string, string>("fd-5", "snp"),
												 pair<string, string>("fd-0", "indel"),
												 pair<string, string>("hotspot", "hotspot"),
												 pair<string, string>("mnp", "mnp"),
												 pair<string, string>("snp", "snp"),
												 pair<string, string>("indel", "indel")};

	map<string, string>::const_iterator map_it = kTypeMap.find(my_type);
	if (map_it == kTypeMap.end()){
		cerr << "ERROR: Unkown BasicFilter type: " << my_type << endl;
		exit(-1);
	}
	// First get parameter from the "torrent_variant_caller" section
	opt_prefix = map_it->second + "-";
	if (map_it->second != my_type){
    	cout << endl << "Retrieving the " << map_it->second << " parameters that will be propagate to the " << my_type << " parameters:" << endl;
	}

	if (default_basic_filter == NULL){
		default_basic_filter = this;
	}

	min_cov_each_strand        = RetrieveParameterInt   (opts, tvc_params, '-', opt_prefix + "min-cov-each-strand", default_basic_filter->min_cov_each_strand);
	min_quality_score          = RetrieveParameterDouble(opts, tvc_params, '-', opt_prefix + "min-variant-score", default_basic_filter->min_quality_score);
	min_allele_freq            = RetrieveParameterDouble(opts, tvc_params, '-', opt_prefix + "min-allele-freq", default_basic_filter->min_allele_freq);
	min_cov                    = RetrieveParameterInt   (opts, tvc_params, '-', opt_prefix + "min-coverage", default_basic_filter->min_cov);
	min_var_cov                = RetrieveParameterInt   (opts, tvc_params, '-', opt_prefix + "min-var-coverage", default_basic_filter->min_var_cov);
	strand_bias_threshold      = RetrieveParameterDouble(opts, tvc_params, '-', opt_prefix + "strand-bias", default_basic_filter->strand_bias_threshold);
	strand_bias_pval_threshold = RetrieveParameterDouble(opts, tvc_params, '-', opt_prefix + "strand-bias-pval", default_basic_filter->strand_bias_pval_threshold);
	if (map_it->second != my_type){
    	cout << "Translating the above " << map_it->second << " parameters to the " << my_type << " parameters." << endl;
	}

	// Then get parameter from the subsection in "torrent_variant_caller"
	opt_prefix = my_type + "-";
	if (tvc_params.isMember(underscored_my_type)){
		string underscored_opt_prefix = underscored_my_type + "_";
		tvc_params_section = tvc_params[underscored_my_type];
		vector<string> keys = tvc_params_section.getMemberNames();
		for (vector<string>::iterator key_it = keys.begin(); key_it != keys.end(); ++key_it){
			// In case some one have something like this "fd_0": {"fd_0_min_allele_freq": 0.1,} while I suppose to see something like this "fd_0": {"min_allele_freq": 0.1,}
			tvc_params_section.removeMember(underscored_opt_prefix + *key_it);
			tvc_params_section[underscored_opt_prefix + *key_it] = tvc_params_section[*key_it];
		}
	}

	cout << "Retrieving the " << my_type << " parameters from the command line and parameter_json[\"torrent_variant_caller\"][\""<< underscored_my_type << "\"]:" << endl;
	min_cov_each_strand        = RetrieveParameterInt   (opts, tvc_params_section, '-', opt_prefix + "min-cov-each-strand", min_cov_each_strand);
	min_quality_score          = RetrieveParameterDouble(opts, tvc_params_section, '-', opt_prefix + "min-variant-score", min_quality_score);
	min_allele_freq            = RetrieveParameterDouble(opts, tvc_params_section, '-', opt_prefix + "min-allele-freq", min_allele_freq);
	min_cov                    = RetrieveParameterInt   (opts, tvc_params_section, '-', opt_prefix + "min-coverage", min_cov);
	min_var_cov                = RetrieveParameterInt   (opts, tvc_params_section, '-', opt_prefix + "min-var-coverage", min_var_cov);
	strand_bias_threshold      = RetrieveParameterDouble(opts, tvc_params_section, '-', opt_prefix + "strand-bias", strand_bias_threshold);
	strand_bias_pval_threshold = RetrieveParameterDouble(opts, tvc_params_section, '-', opt_prefix + "strand-bias-pval", strand_bias_pval_threshold);
	cout << "(Note): Here, \"builtin default\" may be referred to as the the parameter has been set previously." << endl
		 << "Retrieving " << my_type << " parameter set complete." << endl;

}


void BasicFilters::CheckBasicFiltersLimits(){
	string opt_prefix = my_type + "-";
	CheckParameterLowerBound<int>       (opt_prefix + "min-cov-each-strand",  min_cov_each_strand, 0);
	CheckParameterLowerBound<float>     (opt_prefix + "min-variant-score",    min_quality_score,   0.0f);
	CheckParameterLowerUpperBound<float>(opt_prefix + "min-allele-freq",      min_allele_freq,     0.0f, 1.0f);
	CheckParameterLowerBound<int>       (opt_prefix + "min-coverage",         min_cov,             0);
	CheckParameterLowerUpperBound<float>(opt_prefix + "strand-bias",          strand_bias_threshold,  0.5f, 1.0f);
	CheckParameterLowerUpperBound<float>(opt_prefix + "strand-bias-pval",     strand_bias_pval_threshold,  0.0f, 1.0f);
	CheckParameterLowerBound<int>       (opt_prefix + "min-var-coverage",     min_var_cov,         0);
}

// ===========================================================================

void ControlCallAndFilters::CheckParameterLimits() {

	CheckParameterLowerBound<float>     ("data-quality-stringency",   data_quality_stringency,    0.0f);
	CheckParameterLowerUpperBound<float>("read-rejection-threshold",  read_rejection_threshold,   0.0f, 1.0f);
	CheckParameterLowerUpperBound<int>  ("downsample-to-coverage",    downSampleCoverage,         20, 200000);
	CheckParameterLowerUpperBound<float>("position-bias-ref-fraction",position_bias_ref_fraction, 0.0f, 1.0f);
	CheckParameterLowerUpperBound<float>("position-bias",             position_bias,              0.0f, 1.0f);
	CheckParameterLowerUpperBound<float>("position-bias-pval",        position_bias_pval,         0.0f, 1.0f);
	CheckParameterLowerUpperBound<float>("tune-sbias",                sbias_tune,                 0.001f, 1000.0f);
	CheckParameterLowerBound<float>     ("lod-multiplier",            lod_multiplier,             0.0f);
	CheckParameterLowerBound<int>       ("tag-sim-max-cov",           tag_sim_max_cov,            0);
    CheckParameterLowerUpperBound<float>("min-read-ratio-for-fd",     min_ratio_for_fd,           0.0f, 1.0f);
	CheckParameterLowerBound<int>       ("fd-nonsnp-min-var-cov",     fd_nonsnp_min_var_cov,      0);

	filter_variant.CheckParameterLimits();
	filter_snp.CheckBasicFiltersLimits();
	filter_mnp.CheckBasicFiltersLimits();
	filter_hp_indel.CheckBasicFiltersLimits();
	filter_hotspot.CheckBasicFiltersLimits();
	filter_fd_0.CheckBasicFiltersLimits();
	filter_fd_5.CheckBasicFiltersLimits();
	filter_fd_10.CheckBasicFiltersLimits();
}

// ------------------------------------------------------

void ControlCallAndFilters::SetOpts(OptArgs &opts, Json::Value& tvc_params) {

  filter_variant.SetOpts(opts, tvc_params);
  RandSeed = 631;    // Not exposed to user at this point

  // catchall filter parameter to be used to filter any generic predictive model of quality
  data_quality_stringency               = RetrieveParameterDouble(opts, tvc_params, '-', "data-quality-stringency",4.0f);
  // if we reject half the reads from evaluator, something badly wrong with this position
  read_rejection_threshold              = RetrieveParameterDouble(opts, tvc_params, '-', "read-rejection-threshold",0.5f);

  use_position_bias                     = RetrieveParameterBool(opts, tvc_params, '-', "use-position-bias", false);
  position_bias_ref_fraction            = RetrieveParameterDouble(opts, tvc_params, '-', "position-bias-ref-fraction",0.05f);
  position_bias                         = RetrieveParameterDouble(opts, tvc_params, '-', "position-bias",0.75f);
  position_bias_pval                    = RetrieveParameterDouble(opts, tvc_params, '-', "position-bias-pval",0.05f);

  use_lod_filter                        = RetrieveParameterBool(opts, tvc_params, '-', "use-lod-filter", false);
  lod_multiplier                        = RetrieveParameterDouble(opts, tvc_params, '-', "lod-multiplier",0.6f);

  tag_sim_max_cov                       = RetrieveParameterInt   (opts, tvc_params, '-', "tag-sim-max-cov", 20);
  downSampleCoverage                    = RetrieveParameterInt   (opts, tvc_params, '-', "downsample-to-coverage", 2000);

  // VCF record filters XXX
  //filter_by_target                      = RetrieveParameterBool  (opts, tvc_params, '-', "filter-by-target", true);
  //hotspot_positions_only                = RetrieveParameterBool  (opts, tvc_params, '-', "hotspot-positions-only", false);
  //hotspot_variants_only                 = RetrieveParameterBool  (opts, tvc_params, '-', "hotspot-variants-only", false);
  
  //xbias_tune                            = RetrieveParameterDouble(opts, tvc_params, '-', "tune-xbias", 0.005f);
  sbias_tune                            = RetrieveParameterDouble(opts, tvc_params, '-', "tune-sbias", 0.01f);

  suppress_reference_genotypes          = RetrieveParameterBool   (opts, tvc_params, '-', "suppress-reference-genotypes", true);
  suppress_nocall_genotypes             = RetrieveParameterBool   (opts, tvc_params, '-', "suppress-nocall-genotypes", true);
  suppress_no_calls                     = RetrieveParameterBool   (opts, tvc_params, '-', "suppress-no-calls", true);

  // Deprecate heal-snps
  cleanup_unlikely_candidates           = RetrieveParameterBool   (opts, tvc_params, '-', "heal-snps", true);
  cleanup_unlikely_candidates           = RetrieveParameterBool   (opts, tvc_params, '-', "cleanup-unlikely-candidates", cleanup_unlikely_candidates);
  report_ppa                            = RetrieveParameterBool   (opts, tvc_params, '-', "report-ppa", false);
  hotspots_as_de_novo                   = RetrieveParameterBool   (opts, tvc_params, '-', "hotspots-as-de-novo", false);
  disable_filters                       = RetrieveParameterBool   (opts, tvc_params, '-', "disable-filters", false);

  // Flow-disruption related
  fd_nonsnp_min_var_cov                 = RetrieveParameterInt   (opts, tvc_params, '-', "fd-nonsnp-min-var-cov", 0);
  use_fd_param                          = RetrieveParameterBool  (opts, tvc_params, '-', "use-fd-param", false);
  min_ratio_for_fd                      = RetrieveParameterDouble(opts, tvc_params, '-', "min-ratio-for-fd", 0.1);

  filter_snp.SetBasicFilterOpts(opts, tvc_params, NULL);
  // Default: mnp behaves like snp
  filter_mnp.SetBasicFilterOpts(opts, tvc_params, &filter_snp);
  filter_hp_indel.SetBasicFilterOpts(opts, tvc_params, NULL);

  filter_fd_0.SetBasicFilterOpts(opts, tvc_params, NULL);
  // Default: fd-5 behaves like fd-0.
  filter_fd_5.SetBasicFilterOpts(opts, tvc_params, &filter_fd_0);
  filter_fd_10.SetBasicFilterOpts(opts, tvc_params, NULL);
  // Default: HS behaves like the most aggresive one.
  if (use_fd_param){
	  filter_hotspot.SetBasicFilterOpts(opts, tvc_params, &filter_fd_10);
  }
  else{
	  filter_hotspot.SetBasicFilterOpts(opts, tvc_params, &filter_snp);
  }
}

// =============================================================================

void ProgramControlSettings::CheckParameterLimits() {

  CheckParameterLowerUpperBound<int>  ("num-threads",              nThreads,             1, 128);
  CheckParameterLowerUpperBound<int>  ("num-variants-per-thread",  nVariantsPerThread,   1, 10000);

  for(unsigned int i_freq = 0; i_freq < multi_min_allele_freq.size(); ++i_freq){
	  string identifier = "multi-min-allele-freq[" + convertToString(i_freq) + "]";
	  CheckParameterLowerUpperBound<float>  (identifier, multi_min_allele_freq[i_freq], 0.0f, 1.0f);
  }
}

void ProgramControlSettings::SetOpts(OptArgs &opts, Json::Value &tvc_params) {

  DEBUG                                 = opts.GetFirstInt   ('d', "debug", 0);
  nThreads                              = RetrieveParameterInt   (opts, tvc_params, 'n', "num-threads", 12);
  nVariantsPerThread                    = RetrieveParameterInt   (opts, tvc_params, 'N', "num-variants-per-thread", 250);
#ifdef __SSE3__
  use_SSE_basecaller                    = RetrieveParameterBool  (opts, tvc_params, '-', "use-sse-basecaller", true);
#else
  use_SSE_basecaller                    = RetrieveParameterBool  (opts, tvc_params, '-', "use-sse-basecaller", false);
#endif
  // decide diagnostic
  rich_json_diagnostic                  = RetrieveParameterBool  (opts, tvc_params, '-', "do-json-diagnostic", false);
  minimal_diagnostic                    = RetrieveParameterBool  (opts, tvc_params, '-', "do-minimal-diagnostic", false);

  inputPositionsOnly                    = RetrieveParameterBool  (opts, tvc_params, '-', "process-input-positions-only", false);
  suppress_recalibration                = RetrieveParameterBool  (opts, tvc_params, '-', "suppress-recalibration", true);
  resolve_clipped_bases                 = RetrieveParameterBool  (opts, tvc_params, '-', "resolve-clipped-bases", false);

  use_SSE_basecaller                    = RetrieveParameterBool  (opts, tvc_params, '-', "use-sse-basecaller", true);

  do_indel_assembly                     = RetrieveParameterBool  (opts, tvc_params, '-', "do-indel-assembly", true);

  is_multi_min_allele_freq              = RetrieveParameterBool  (opts, tvc_params, '-', "output-multi-min-allele-freq", false);

  RetrieveParameterVectorFloat(opts, tvc_params, '-', "multi-min-allele-freq", "0.05,0.1,0.15,0.2", multi_min_allele_freq);
}

// ===========================================================================

bool ExtendParameters::ValidateAndCanonicalizePath(string &path)
{
  char *real_path = realpath (path.c_str(), NULL);
  if (real_path == NULL) {
    perror(path.c_str());
    exit(EXIT_FAILURE);
  }
  path = real_path;
  free(real_path);
  return true;
}

void ExtendParameters::SetupFileIO(OptArgs &opts, Json::Value& tvc_params) {
  // freeBayes slot
  fasta                                 = opts.GetFirstString('r', "reference", "");
  if (fasta.empty()) {
    cerr << "Fatal ERROR: Reference file not specified via -r" << endl;
    exit(1);
  }
  ValidateAndCanonicalizePath(fasta);

  // freeBayes slot
  blacklistFile                     = opts.GetFirstString('l', "sse-vcf", "");
  if (blacklistFile.empty()) {
	cerr << "INFO: No sse VCF file specified via -l,--sse-vcf" << endl;
  }
  else
	ValidateAndCanonicalizePath(blacklistFile);
  variantPriorsFile                     = opts.GetFirstString('c', "input-vcf", "");
  if (variantPriorsFile.empty()) {
    cerr << "INFO: No input VCF (Hotspot) file specified via -c,--input-vcf" << endl;
  }
  else
	ValidateAndCanonicalizePath(variantPriorsFile);

  sseMotifsDir                          = opts.GetFirstString('-', "error-motifs-dir", "");
  sseMotifsFileName = RetrieveParameterString  (opts, tvc_params, 'e', "error-motifs", "");
  size_t pos = sseMotifsFileName.rfind("/");
  if ((!sseMotifsDir.empty()) && (pos != std::string::npos) && (pos < sseMotifsFileName.length() - 1)) {
      sseMotifsFileName = sseMotifsFileName.substr(pos + 1);
  }
  if (sseMotifsDir != "") {sseMotifsFileName = sseMotifsDir + "/" + sseMotifsFileName;}
  sseMotifsProvided = true;
  if (sseMotifsFileName.empty()) {
    sseMotifsProvided = false;
    cerr << "INFO: Systematic error motif file not specified via -e" << endl;
  }
  else {
    cout << "INFO: Using error-motifs file:\t" << sseMotifsFileName << endl;
    ValidateAndCanonicalizePath(sseMotifsFileName);
  }

  opts.GetOption(bams, "", 'b', "input-bam");
  if (bams.empty()) {
    cerr << "FATAL ERROR: BAM file not specified via -b" << endl;
    exit(-1);
  }
  for (unsigned int i_bam = 0; i_bam < bams.size(); ++i_bam)
    ValidateAndCanonicalizePath(bams[i_bam]);

  outputDir                             = opts.GetFirstString('O', "output-dir", ".");
  mkpath(outputDir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
  ValidateAndCanonicalizePath(outputDir);

  // Parse output file names
  small_variants_vcf                    = opts.GetFirstString('o', "output-vcf",   "small_variants.vcf");
  if (small_variants_vcf.empty()) {
    cerr << "Fatal ERROR: Output VCF filename not specified via -o or --output-vcf" << endl;
    exit(1);
  }

  indel_assembly_vcf                    = opts.GetFirstString('-', "assembly-vcf", "indel_assembly.vcf");
  if (indel_assembly_vcf.empty()) {
    cerr << "Fatal ERROR: Assembly VCF filename not specified via --assembly-vcf" << endl;
    exit(1);
  }

  // XXX VCF merging not being done in TVC 5.4 but in the varriant caller pipeline
  //merged_vcf                            = opts.GetFirstString('o', "merged-vcf",   "TSVC_variants.vcf");
  //if (merged_vcf.empty()) {
  //  cerr << "Fatal ERROR: Merged VCF filename not specified via --merged-vcf" << endl;
  //  exit(1);
  //}
  // Gvcf file name is the same as merged vcf file, but with different file ending
  //string vcf_file_end(".vcf");
  //merged_genome_vcf = merged_vcf.substr(0, merged_vcf.find(".vcf")) + ".genome.vcf";

  string tmp = opts.GetFirstString('-', "candidate-list-file", "");
  if (tmp.size() > 0) candidate_list = outputDir+ "/" + tmp;
  /*
  tmp = opts.GetFirstString('-', "black-listed-file", "");
  if (tmp.size() > 0) black_listed = outputDir + "/" + tmp;
  */
  black_listed = outputDir + "/black_listed.vcf";

  // Are those file names? - Nope, only the first one!
  postprocessed_bam                     = opts.GetFirstString('-', "postprocessed-bam", "");
  sampleName                            = opts.GetFirstString('g', "sample-name", "");
  force_sample_name                     = opts.GetFirstString('-', "force-sample-name", "");
  // TS 5.4: Multisample currently produces core dumps. Deactivated unless override-limits is specified.
  //multisample                           = RetrieveParameterBool  (opts, tvc_params, '-', "multisample-analysis", false);
  // Allow command line only and do not report in log.
  multisample                           = opts.GetFirstBoolean('-', "multisample-analysis", false);
}

// ------------------------------------------------------------

void ExtendParameters::SetFreeBayesParameters(OptArgs &opts, Json::Value& fb_params) {
  // FreeBayes parameters
  // primarily used in candidate generation
  // Note: Abuse of fb_params here. The following parameters will get into TargetsManager and won't be the part of Freebayes.
  targets                               = opts.GetFirstString('t', "target-file", "");
  trim_ampliseq_primers                 = opts.GetFirstBoolean('-', "trim-ampliseq-primers", false);
  min_cov_fraction                      = RetrieveParameterDouble(opts, fb_params, '-', "min-cov-fraction", 0.0);

  if (targets.empty() and trim_ampliseq_primers) {
    cerr << "ERROR: --trim-ampliseq-primers enabled but no --target-file provided" << endl;
    exit(1);
  }

  allowIndels                           = RetrieveParameterBool  (opts, fb_params, '-', "allow-indels", true);
  allowSNPs                             = RetrieveParameterBool  (opts, fb_params, '-', "allow-snps", true);
  allowMNPs                             = RetrieveParameterBool  (opts, fb_params, '-', "allow-mnps", true);
  allowComplex                          = RetrieveParameterBool  (opts, fb_params, '-', "allow-complex", false);
  mergeLookAhead			            = RetrieveParameterInt   (opts, fb_params, '-', "merge-variant-lookahead", -1);
  output_allele_cigar                   = RetrieveParameterBool  (opts, fb_params, '-', "allele-cigar-output", false);
  
  // deprecated:
  // leftAlignIndels                       = RetrieveParameterBool  (opts, fb_params, '-', "left-align-indels", false);
  RetrieveParameterBool  (opts, fb_params, '-', "left-align-indels", false);
  
  //useBestNAlleles = 0;
  useBestNAlleles                       = RetrieveParameterInt   (opts, fb_params, 'm', "use-best-n-alleles", 2);
  useBestNTotalAlleles 			        = RetrieveParameterInt   (opts, fb_params, '-', "use-best-n-nonsnp-alleles", 0);
  max_alt_num                           = RetrieveParameterInt   (opts, fb_params, '-', "max-alt-num", 20);
  onlyUseInputAlleles                   = RetrieveParameterBool  (opts, fb_params, '-', "use-input-allele-only", false);
  min_mapping_qv                        = RetrieveParameterInt   (opts, fb_params, 'M', "min-mapping-qv", 4);
  read_snp_limit                        = RetrieveParameterInt   (opts, fb_params, 'U', "read-snp-limit", 10);
  readMaxMismatchFraction               = RetrieveParameterDouble(opts, fb_params, 'z', "read-max-mismatch-fraction", 1.0);
  read_mismatch_limit                   = RetrieveParameterInt   (opts, fb_params, '-', "read-mismatch-limit", 0);
  maxComplexGap                         = RetrieveParameterInt   (opts, fb_params, '!', "max-complex-gap", 1);
  // read from json or command line, otherwise default to snp frequency
  minAltFraction                        = RetrieveParameterDouble(opts, fb_params, '-', "gen-min-alt-allele-freq", my_controls.filter_snp.min_allele_freq);
  minCoverage                           = RetrieveParameterInt   (opts, fb_params, '-', "gen-min-coverage", my_controls.filter_snp.min_cov);
  minIndelAltFraction                   = RetrieveParameterDouble(opts, fb_params, '-', "gen-min-indel-alt-allele-freq", my_controls.filter_hp_indel.min_allele_freq);
  //set up debug levels

  debug = program_flow.DEBUG > 0;
  processInputPositionsOnly = program_flow.inputPositionsOnly;

  if (variantPriorsFile.empty() and (processInputPositionsOnly or onlyUseInputAlleles) ) {
    cerr << "ERROR: Parameter error - Process-input-positions-only: " << processInputPositionsOnly << " use-input-allele-only: " << onlyUseInputAlleles << " :  Specified without Input VCF File " << endl;
    exit(1);
  }
}

// ------------------------------------------------------------

void ExtendParameters::ParametersFromJSON(OptArgs &opts, Json::Value &tvc_params, Json::Value &freebayes_params, Json::Value &params_meta) {
  string parameters_file                = opts.GetFirstString('-', "parameters-file", "");
  Json::Value parameters_json(Json::objectValue);
  if (not parameters_file.empty()) {
    ifstream in(parameters_file.c_str(), ifstream::in);

    if (!in.good()) {
      fprintf(stderr, "[tvc] FATAL ERROR: cannot open %s\n", parameters_file.c_str());
      exit(-1);
    }
    
    // This line can cause seg-faults if we don't have a json file at the input
    in >> parameters_json;
    in.close();
    if (parameters_json.isMember("pluginconfig"))
      parameters_json = parameters_json["pluginconfig"];

    tvc_params = parameters_json.get("torrent_variant_caller", Json::objectValue);
    freebayes_params = parameters_json.get("freebayes", Json::objectValue);
    params_meta = parameters_json.get("meta", Json::objectValue);
  }
}

// ------------------------------------------------------------

void ExtendParameters::CheckParameterLimits() {
  // Check in the order they were set
  my_controls.CheckParameterLimits();
  my_eval_control.CheckParameterLimits();
  program_flow.CheckParameterLimits();

  // Checking FreeBayes parameters
  CheckParameterLowerUpperBound<float>("min-cov-fraction",           min_cov_fraction,             0.0f, 1.0f);
  CheckParameterLowerUpperBound<int>  ("use-best-n-alleles",         useBestNAlleles,              0,    20);
  CheckParameterLowerUpperBound<int>  ("use-best-n-nonsnp-alleles",  useBestNTotalAlleles,	       0,    20);
  CheckParameterLowerBound<int>       ("min-mapping-qv",             min_mapping_qv,               0);
  CheckParameterLowerBound<int>       ("read-snp-limit",             read_snp_limit,               0);
  CheckParameterLowerUpperBound<float>("read-max-mismatch-fraction", readMaxMismatchFraction,      0.0f, 1.0f);
  CheckParameterLowerBound<int>       ("read-mismatch-limit",        read_mismatch_limit,          0);
  CheckParameterLowerUpperBound<long double>("gen-min-alt-allele-freq",       minAltFraction,      0.0, 1.0);
  CheckParameterLowerBound<int>             ("gen-min-coverage",              minCoverage,         0);
  CheckParameterLowerBound<int>             ("max-alt-num",                   max_alt_num,         1);
  CheckParameterLowerUpperBound<long double>("gen-min-indel-alt-allele-freq", minIndelAltFraction, 0.0, 1.0);

  // Checking TagTrimmerParameters
  CheckParameterLowerUpperBound<int>  ("tag-trim-method",        tag_trimmer_parameters.tag_trim_method,        0, 1);
  CheckParameterLowerBound<int>       ("min-tag-fam-size",       tag_trimmer_parameters.min_family_size,        1);
  CheckParameterLowerBound<int>       ("indel-func-size-offset", tag_trimmer_parameters.indel_func_size_offset, 0);
}

void ExtendParameters::SetMolecularTagTrimmerOpt(Json::Value& tvc_params)
{
	enum TagFilterOptions {
	  kneed_only_prefix_tag,
	  kneed_only_suffix_tag,
	  kneed_all_tags,
	};

	enum TagTrimMethod {
	  kStrictTrim,
	  kSloppyTrim,
	  kUnknownTrim
	};

	tag_trimmer_parameters.suppress_mol_tags      = RetrieveParameterBool   (opts, tvc_params, '-', "suppress-mol-tags", false);
	tag_trimmer_parameters.min_family_size        = RetrieveParameterInt    (opts, tvc_params, '-', "min-tag-fam-size", 3);
	tag_trimmer_parameters.indel_func_size_offset = RetrieveParameterInt    (opts, tvc_params, '-', "indel-func-size-offset", 0);
	string trim_method                            = RetrieveParameterString (opts, tvc_params, '-', "tag-trim-method", "sloppy-trim");

	if (trim_method == "sloppy-trim" or trim_method == "sloppy_trim")
		tag_trimmer_parameters.tag_trim_method = kSloppyTrim;
	else if (trim_method == "strict-trim" or trim_method == "strict_trim")
		tag_trimmer_parameters.tag_trim_method = kStrictTrim;
	else {
		tag_trimmer_parameters.tag_trim_method = kUnknownTrim;
	}
	// tvc requires need all tags
    tag_trimmer_parameters.tag_filter_method = kneed_all_tags;

}

// ------------------------------------------------------------

ExtendParameters::ExtendParameters(int argc, char** argv)
{
  // i/o parameters:
  // file names use default string constructor = ""

  // operation parameters
  trim_ampliseq_primers = false;
  min_cov_fraction = 0.0f;
  useDuplicateReads = false;      // -E --use-duplicate-reads
  useBestNAlleles = 0;         // -n --use-best-n-alleles
  allowIndels = true;            // -i --no-indels
  allowMNPs = true;            // -X --no-mnps
  allowSNPs = true;          // -I --no-snps
  allowComplex = false;
  maxComplexGap = 3;
  onlyUseInputAlleles = false;
  min_mapping_qv = 0;                    // -m --min-mapping-quality
  readMaxMismatchFraction = 1.0;    //  -z --read-max-mismatch-fraction
  read_mismatch_limit = 0;
  read_snp_limit = 10000000;       // -$ --read-snp-limit
  minAltFraction = 0.2;  // require 20% of reads from sample to be supporting the same alternate to consider
  minIndelAltFraction = 0.2;
  minAltCount = 2; // require 2 reads in same sample call
  minAltTotal = 1;
  minCoverage = 0;
  debug = false;
  multisample = false;

  processInputPositionsOnly = false;

  //OptArgs opts;
  opts.ParseCmdLine(argc, (const char**)argv);

  if (argc == 1) {
    VariantCallerHelp();
    exit(0);
  }
  if (opts.GetFirstBoolean('v', "version", false)) {
    exit(0);
  }
  if (opts.GetFirstBoolean('h', "help", false)) {
    VariantCallerHelp();
    exit(0);
  }

  Json::Value tvc_params(Json::objectValue);
  Json::Value freebayes_params(Json::objectValue);
  Json::Value params_meta(Json::objectValue);
  ParametersFromJSON(opts, tvc_params, freebayes_params, params_meta);

  SetupFileIO(opts, tvc_params);

  my_controls.SetOpts(opts, tvc_params);
  my_eval_control.SetOpts(opts, tvc_params);
  program_flow.SetOpts(opts, tvc_params);

  // Create output directory for diagnostic if desired
  if (program_flow.rich_json_diagnostic || program_flow.minimal_diagnostic) {
    json_plot_dir = outputDir + "/json_diagnostic/";
    mkpath(json_plot_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    ValidateAndCanonicalizePath(outputDir);
  }

  // tag_trimmer_parameters = MolecularTagTrimmer::ReadOpts(opts); // not read from json!
  // Get tag trimmer parameters
  SetMolecularTagTrimmerOpt(tvc_params);

  // Dummy lines for HP recalibration
  recal_model_file_name = opts.GetFirstString ('-', "model-file", "");
  recalModelHPThres = opts.GetFirstInt('-', "recal-model-hp-thres", 4);

  SetFreeBayesParameters(opts, freebayes_params);
  bool overrideLimits          = RetrieveParameterBool  (opts, tvc_params, '-', "override-limits", false);

  prefixExclusion =  opts.GetFirstInt('-', "prefix-exclude", 6);
  cerr << "prefix-exclude = " <<  prefixExclusion << endl;

  params_meta_name = params_meta.get("name",string()).asString();
  params_meta_details = params_meta.get("configuration_name", string()).asString();
  string external_file = params_meta.get("external_file", string()).asString();
  if (not external_file.empty()) {
    if (not params_meta_details.empty()) {params_meta_details += ", ";}
    params_meta_details += external_file;
  }
  string repository_id = params_meta.get("repository_id",string()).asString();
  string ts_version = params_meta.get("ts_version","").asString();
  if (not repository_id.empty()) {
    if (not params_meta_details.empty())
      params_meta_details += ", ";
    params_meta_details += repository_id;
  }
  if (not ts_version.empty()) {
    if (not params_meta_details.empty())
      params_meta_details += ", ";
    params_meta_details += "TS version: ";
    params_meta_details += ts_version;
  }


  //  opts.CheckNoLeftovers();
  // Sanity checks on input variables once all are set.
  if (!overrideLimits){
    if (multisample){
    	cout << "Limit check parameter multisample-analysis: Using multsample_analysis=false instead." << endl;
    	multisample = false;
    }

    CheckParameterLimits();
  }

  if (my_controls.disable_filters){
	  cout << "tvc will disable all the post-evaluation filters." << endl;
	  my_controls.suppress_reference_genotypes = false;
	  my_controls.suppress_nocall_genotypes = false;
	  my_controls.cleanup_unlikely_candidates = false;
	  my_controls.suppress_no_calls = false;
  }
}
