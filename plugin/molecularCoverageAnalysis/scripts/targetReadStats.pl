#!/usr/bin/perl
# Copyright (C) 2015 Ion Torrent Systems, Inc. All Rights Reserved

#--------- Begin command arg parsing ---------

(my $CMD = $0) =~ s{^(.*/)+}{};
my $DESCR = "Create statistics for a target read coverage file (to STDOUT).
The file format is a table file with fields as generated by bbctools.
By default coverage is assumed to be by reads per individual target, sorted on the 'coverage depth' field (9).
The -a or -r options should be used if the input is for amplicon targets.
The -b option should be used if the input is for targets measured by average base coverage and possibly
merged targets (as produced by bbcStats.pl). Options include output of a depth of coverage distribution table.";
my $USAGE = "Usage:\n\t$CMD [options] <target coverage file>";
my $OPTIONS = "Options:
  -h ? --help Display Help information
  -a Indicates target regions are Amplicons rather than generic targets. Overrides -b option and changes wording of output.
  -b Indicates target region coverage is measured by average Base coverage depth and that targets may be merged.
  -c Input file is contig reads summary. Targets are contigs; log10 reads output and no end-to-end. (Overrides -a, -b & -r options.)
  -f Full stats mode. Includes a few additional statistics in the report.
  -l Show extra log information to STDERR.
  -r RNA AmpliSeq option: Coverage statistics output at log10 depths. Forces '-a' option.
  -C <pcnt> Percentage of target length covered by at least one base read for target to be considered 'fully' covered. Default: 98.
  -D <file> Output file name for depth of coverage Distribution table (tsv) file. Default: '' (None output).
  -E <pcnt> Threshold for end-to-end read counting based on percent end-to-end reads greater or equal to <pcnt>. Default: 70.
  -K <list> List of read depths at which percentage of target coverage is reported. Default: '20,100,500'.
  -P <pcnt> Percentage of assigned mapped reads. If provided this will be output as the percent assigned reads statistic.
  -M <int>  Number of Mapped reads. If provided the percent assigned reads statistic will be output (unless -b option used).
  -R <int>  Threshold for Read coverage for strand bias to be counted. Reset to 1 if less. Default: 10 reads/bases.
  -S <pcnt> Threshold for strand Bias counting based on percent forward reads being between <pcnt> and 100-<pcnt>. Default: 70.";

my $docfile = '';
my $logopt = 0;
my $ampout = 0;
my $rnaopt = 0;
my $fullstats = 0;
my $mappedReads = -1;
my $pc_mappedReads = -1;
my $thresE2E = 70;
my $thresBias = 70;
my $thresReads = 10;
my $basedepths = 0;
my $fullycov = 98;
my $contigs = 0;
my $covDepths = "20,100,500";

my $help = (scalar(@ARGV) == 0);
while( scalar(@ARGV) > 0 )
{
  last if($ARGV[0] !~ /^-/);
  my $opt = shift;
  if($opt eq '-D') {$docfile = shift;}
  elsif($opt eq '-a') {$ampout = 1;}
  elsif($opt eq '-b') {$basedepths = 1;}
  elsif($opt eq '-c') {$contigs = 1;}
  elsif($opt eq '-f') {$fullstats = 1;}
  elsif($opt eq '-l') {$logopt = 1;}
  elsif($opt eq '-r') {$rnaopt = 1;$ampout = 1;}
  elsif($opt eq '-C') {$fullycov = (shift)+0;}
  elsif($opt eq '-E') {$thresE2E = (shift)+0;}
  elsif($opt eq '-K') {$covDepths = shift;}
  elsif($opt eq '-P') {$pc_mappedReads = (shift)+0;}
  elsif($opt eq '-M') {$mappedReads = int(shift);}
  elsif($opt eq '-R') {$thresReads = (shift)+0;}
  elsif($opt eq '-S') {$thresBias = (shift)+0;}
  elsif($opt eq '-h' || $opt eq "?" || $opt eq '--help') {$help = 1;}
  else
  {
    print STDERR "$CMD: Invalid option argument: $opt\n";
    print STDERR "$OPTIONS\n";
    exit 1;
  }
}
my $nargs = scalar @ARGV;
if( $help )
{
  print STDERR "$DESCR\n";
  print STDERR "$USAGE\n";
  print STDERR "$OPTIONS\n";
  exit 1;
}
elsif( $nargs != 1 )
{
  print STDERR "$CMD: Invalid number of arguments.\n";
  print STDERR "$USAGE\n";
  exit 1;
}

my $trdfile = shift(@ARGV);

$basedepths = 0 if( $ampopt );
if( $contigs ) {
  $basedepths = $rnaopt = $ampout = 0;
}
# validate thresholds and turn percents to fractions
$thresReads = 1 if( $thresReads < 1 );
$thresBias = 0 if( $thresBias <= 0 );
$thresE2E = 0 if( $thresE2E <= 0 );
$fullycov = 0 if( $fullycov <= 0 );
$thresBias *= 0.01;
$thresE2E  *= 0.01;
$fullycov  *= 0.01;

my $havedoc = ($docfile ne "" && $docfile ne "-" );

my @cov_depths = ();
if( int($covDepths) > 0 ) {
  @cov_depths = split(",",$covDepths);
}

#--------- End command arg parsing ---------

die "Cannot find depth file $trdfile" unless( -e $trdfile );

# open TRDFILE and read header string to detect BED format (ionVersion)
open( TRDFILE, $trdfile ) || die "Failed to open target reads file $trdfile\n";
chomp( my $fieldIDs = <TRDFILE> );
my @fieldNames = split('\t',$fieldIDs);
my $haveNVP = ($fieldName[4] ne "gene_id");

# set defaults for anticipated required field ID indecies
my ($contig_srt,$contig_end,$region_id,$overlaps,$fwd_e2e,$rev_e2e,$cov_dpt,$fwd_reads,$rev_reads) = (1,2,3,6,7,8,9,10,11);

# collect depth distribution : pre-allocate for performance
my @targetDist = ((0)x20000);
my ($targetMaxDepth,$sumBaseDepth,$numTargets,$numBias,$numE2E) = (0,0,0,0,0,0);
my $lthresBias = 1 - $thresBias;
if( $lthresBias > $thresBias )
{
  $thresBias = $lthresBias;
  $lthresBias = 1 - $thresBias;
}

# collect depth-of-reads distribution and read threshold stats
my ($tlen,$depth,$rE2E,$rBias) = (0,0,0,0.5);
while(<TRDFILE>)
{
  chomp;
  my @fields = split('\t',$_);
  next if( $fields[0] !~ /\S/ );
  if( $contigs ) {
    $depth = $fields[1] + $fields[2];
    $rBias = $depth >= $thresReads ? $fields[1]/$depth : 0.5; 
  } else {
    $tlen = $fields[$contig_end] - $fields[$contig_srt] + 1;
    $depth = $fields[$cov_dpt];
    $rE2E  = $basedepths ? ($tlen > 0 ? $fields[$overlaps]/$tlen : 0) : ($depth > 0 ? ($fields[$fwd_e2e]+$fields[$rev_e2e])/$depth : 0); 
    $rBias = $depth >= $thresReads ? $fields[$fwd_reads]/($fields[$fwd_reads]+$fields[$rev_reads]) : 0.5; 
  }
  $targetMaxDepth = $depth if( $depth > $targetMaxDepth );
  if( $basedepths ) {
    my $ntrgs = 1+($haveNVP ? ($fields[$region_id] =~ tr/&/&/) : ($fields[$region_id] =~ tr/,/,/));
    $sumBaseDepth += $depth * $ntrgs;
    $numTargets += $ntrgs;
    $targetDist[int($depth)] += $ntrgs;
    $numE2E += $ntrgs if( $rE2E >= $fullycov );
    $numBias += $ntrgs if( $rBias < $lthresBias || $rBias > $thresBias );
  } else {
    ++$numTargets;
    ++$targetDist[int($depth)];
    ++$numE2E if( $rE2E >= $thresE2E );
    ++$numBias if( $rBias < $lthresBias || $rBias > $thresBias );
    #$numOvlps += $fields[$overlaps];
  }
}
close(TRDFILE);

# create output stats
my $targType = $ampout ? 'Amplicon' : 'Target';
$targType = "Contig" if( $contigs );
my $targetCumd = outputStats( $targType, \@targetDist, $targetMaxDepth, $numTargets, $sumBaseDepth );

my $numNoBias = $numTargets - $numBias;
my $pcBias = $numTargets > 0 ? 100*$numNoBias/$numTargets : 0;
my $pcE2E  = $numTargets > 0 ? 100*$numE2E/$numTargets : 0;
if( $basedepths ) {
  printf "%ss with no strand bias:        %.2f%%\n",$targType,$pcBias;
  printf "%ss with full coverage:         %.2f%%\n",$targType,$pcE2E if( $fullycov > 0 );
} elsif( $rnaopt ) {
  printf "%ss with no strand bias:      %d\n",$targType,$numNoBias;
  printf "%ss reading end-to-end:       %d\n",$targType,$numE2E;
} elsif( $contigs ) {
  printf "%ss with no strand bias:      %d\n",$targType,$numNoBias;
} else {
  printf "%ss with no strand bias:      %.2f%%\n",$targType,$pcBias;
  printf "%ss reading end-to-end:       %.2f%%\n",$targType,$pcE2E if( $ampout );
}

# output assigned read depth distribution
if( $havedoc ) {
  my $header = "read_depth\ttarget_cov\ttarget_cum_cov";
  open( DOCOUT, ">$docfile" ) || die "Cannot open file for writing $docfile.\n";  
  print DOCOUT "$header\n";
  for( my $d = 0; $d <= $targetMaxDepth; ++$d ) {
    printf DOCOUT "%d\t%0.f\t%0.f\n", $d, $targetDist[$d], @{$targetCumd}[$d];
  }
  close( DOCOUT );
}

#-------------------------- End ------------------------

# generates output stats or given depth array and returns reference to cumulative depth array
sub outputStats
{
  my ($tag,$hist,$maxDepth,$numTargs,$sumDepth) = @_;
  my @dist = @{$hist};
  my @cumd;
  my $tagL = lc($tag);
  my $tagU = ucfirst($tagL);
  my ($reads,$sum_reads,$sum_dreads,$cumcov) = (0,0,0,0);
  for( my $depth = int($maxDepth); $depth > 0; --$depth ) {
    $dist[$depth] += 0; # force value
    $cumcov += $dist[$depth];
    $cumd[$depth] = $cumcov; # for medians
    $reads = $depth * $dist[$depth];
    # sums for variance calculation
    $sum_reads += $reads;
    $sum_dreads += $depth * $reads;
  }
  # have to address the element directly, since dist is a copy (?)
  ${$_[1]}[0] = $numTargs - $cumcov;
  $cumd[0] = $numTargs;
  # mean read depth
  my $abc = $sum_reads / $numTargs;
  # mean and stddev for reads with at least 1x coverage ($cumcov == $cumd[1])
  my $ave = $cumcov > 0 ? $sum_reads/$cumcov : 0;
  my $std = $cumcov > 1 ? sqrt(($sum_dreads - $ave*$ave*$cumcov)/($cumcov-1)) : 0;
  my $scl = 100 / $numTargs;
  my $sig = sigfig($abc);
  # uniformity changed from closest cum cov point to interpolation between two points - as seen on plot
  # my $p2m = int(0.2*$abc+0.5); my $uniformity = $cumd[$p2m]*$scl;
  if( $basedepths ) {
    # Cumulative base coverage used integer depths => use more accurate sum & average
    $abc = $sumDepth / $numTargs;
    $sig = sigfig($abc);
    unless( $tagL eq 'contigs' ) {
      printf "Number of unmerged %ss:       %.0f\n",$tagL,$numTargs if( $tagL ne 'contigs' );
      #printf "Total on $tagL mean base reads:  %.0f\n",$sumDepth;
      printf "Percent assigned $tagL reads:    %.2f%%\n",$pc_mappedReads if( $pc_mappedReads >= 0 );
    }
    printf "Average base coverage depth per target: %.${sig}f\n",$abc;
    my $lambda = 0.2*$abc;
    my $p2m = int($lambda);
    $lambda -= $p2m;
    my $uniformity = ((1-$lambda)*$cumd[$p2m] + $lambda*$cumd[$p2m+1])*$scl;
    printf "Uniformity of base coverage per target: %.2f%%\n",$uniformity;
  } else {
    printf "Number of %ss:                %.0f\n",$tagL,$numTargs;
    printf "Total assigned $tagL reads:      %.0f\n",$sum_reads;
    unless( $rnaopt || $contigs ) {
      printf "Percent assigned $tagL reads:    %.2f%%\n",($mappedReads > 0 ? 100*$sum_reads/$mappedReads : 0) if( $mappedReads >= 0 );
      printf "Average reads per $tagL:         %.${sig}f\n",$abc;
      my $lambda = 0.2*$abc;
      my $p2m = int($lambda);
      $lambda -= $p2m;
      my $uniformity = ((1-$lambda)*$cumd[$p2m] + $lambda*$cumd[$p2m+1])*$scl;
      printf "Uniformity of $tagL coverage:    %.2f%%\n",$uniformity;
    }
    if( $fullstats ) {
      printf "%ss with at least 1 read:     %.0f\n",$tagU,$cumcov;
      printf "Maximum $tagL read depth:        %.0f\n",$maxDepth;
      $sig = sigfig($ave);
      printf "Average $tagL read depth:            %.${sig}f\n",$ave;
      $sig = sigfig($std);
      printf "Std.Dev $tagL read depth:            %.${sig}f\n",$std;
    }
  }
  if( $basedepths ) {
    printf "%ss with base coverage at 1x: %.2f%%\n",$tagU,$cumd[1]*$scl;
    for( my $i = 0; $i < scalar(@cov_depths); ++$i ) {
      my $d = int($cov_depths[$i]);
      my $n = 4 - length("$d");
      my $s = $n > 0 ? " " x $n : "";
      printf "%ss with base coverage at %dx: %s%.2f%%\n",$tagU,$d,$n,$cumd[$d]*$scl;
    }
  } elsif( $rnaopt || $contigs ) {
    printf "%ss with at least 1 read:     %d\n",$tagU,$cumd[1];
    printf "%ss with at least 10 reads:   %d\n",$tagU,$cumd[10];
    printf "%ss with at least 100 reads:  %d\n",$tagU,$cumd[100];
    printf "%ss with at least 1000 reads: %d\n",$tagU,$cumd[1000];
    printf "%ss with at least 10K reads:  %d\n",$tagU,$cumd[10000];
    printf "%ss with at least 100K reads: %d\n",$tagU,$cumd[100000];
  } else {
    printf "%ss with at least 1 read: %.2f%%\n",$tagU,$cumd[1]*$scl;
    for( my $i = 0; $i < scalar(@cov_depths); ++$i ) {
      my $d = int($cov_depths[$i]);
      my $n = 4 - length("$d");
      my $s = $n > 0 ? " " x $n : "";
      printf "%ss with at least %d reads: %s%.2f%%\n",$tagU,$d,$s,$cumd[$d]*$scl;
    }
  }
  return \@cumd;
}

sub sigfig
{
  my $val = $_[0];
  return 0 if( $val ) >= 1000;
  return 1 if( $val ) >= 100;
  return 2 if( $val ) >= 10;
  return 3;
}

